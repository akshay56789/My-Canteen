{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadBundleAsync = void 0;\n\nvar HMRClient_1 = __importDefault(require(\"../HMRClient\"));\n\nvar LoadingView_1 = __importDefault(require(\"../LoadingView\"));\n\nvar buildUrlForBundle_1 = require(\"./buildUrlForBundle\");\n\nvar fetchThenEval_1 = require(\"./fetchThenEval\");\n\nvar pendingRequests = 0;\n\nfunction loadBundleAsync(bundlePath) {\n  var requestUrl = (0, buildUrlForBundle_1.buildUrlForBundle)(bundlePath);\n  LoadingView_1.default.showMessage(\"Downloading...\", \"load\");\n  pendingRequests++;\n  return (0, fetchThenEval_1.fetchThenEvalAsync)(requestUrl).then(function () {\n    HMRClient_1.default.registerBundle(requestUrl);\n  }).finally(function () {\n    if (! --pendingRequests) {\n      LoadingView_1.default.hide();\n    }\n  });\n}\n\nexports.loadBundleAsync = loadBundleAsync;","map":{"version":3,"sources":["../../src/async-require/loadBundle.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAMA,IAAA,WAAA,GAAA,eAAA,CAAA,OAAA,gBAAA,CAAA;;AACA,IAAA,aAAA,GAAA,eAAA,CAAA,OAAA,kBAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,OAAA,uBAAA;;AACA,IAAA,eAAA,GAAA,OAAA,mBAAA;;AAEA,IAAI,eAAe,GAAG,CAAtB;;AAOA,SAAgB,eAAhB,CAAgC,UAAhC,EAAkD;EAChD,IAAM,UAAU,GAAG,CAAA,GAAA,mBAAA,CAAA,iBAAA,EAAkB,UAAlB,CAAnB;EAGA,aAAA,CAAA,OAAA,CAAY,WAAZ,CAAwB,gBAAxB,EAA0C,MAA1C;EACA,eAAe;EAEf,OAAO,CAAA,GAAA,eAAA,CAAA,kBAAA,EAAmB,UAAnB,EACJ,IADI,CACC,YAAK;IACT,WAAA,CAAA,OAAA,CAAU,cAAV,CAAyB,UAAzB;EACD,CAHI,EAIJ,OAJI,CAII,YAAK;IACZ,IAAI,CAAC,GAAE,eAAP,EAAwB;MACtB,aAAA,CAAA,OAAA,CAAY,IAAZ;IACD;EACF,CARI,CAAP;AASD;;AAhBD,OAAA,CAAA,eAAA,GAAA,eAAA","sourcesContent":["/**\n * Copyright Â© 2022 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport HMRClient from \"../HMRClient\";\nimport LoadingView from \"../LoadingView\";\nimport { buildUrlForBundle } from \"./buildUrlForBundle\";\nimport { fetchThenEvalAsync } from \"./fetchThenEval\";\n\nlet pendingRequests = 0;\n\n/**\n * Load a bundle for a URL using fetch + eval on native and script tag injection on web.\n *\n * @param bundlePath Given a statement like `import('./Bacon')` `bundlePath` would be `Bacon.bundle?params=from-metro`.\n */\nexport function loadBundleAsync(bundlePath: string): Promise<void> {\n  const requestUrl = buildUrlForBundle(bundlePath);\n\n  // Send a signal to the `expo` package to show the loading indicator.\n  LoadingView.showMessage(\"Downloading...\", \"load\");\n  pendingRequests++;\n\n  return fetchThenEvalAsync(requestUrl)\n    .then(() => {\n      HMRClient.registerBundle(requestUrl);\n    })\n    .finally(() => {\n      if (!--pendingRequests) {\n        LoadingView.hide();\n      }\n    });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}