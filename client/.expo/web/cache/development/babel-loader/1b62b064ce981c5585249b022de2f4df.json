{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport * as SplashModule from \"expo-splash-screen\";\nimport { nanoid } from \"nanoid/non-secure\";\nimport * as React from \"react\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nvar globalStack = [];\nexport function SplashScreen() {\n  useGlobalSplash();\n  React.useEffect(function () {\n    console.warn(\"The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.\");\n  }, []);\n  return null;\n}\n\nfunction useGlobalSplash() {\n  var stack = React.useRef(null);\n  React.useEffect(function () {\n    stack.current = SplashScreen._pushEntry();\n    return function () {\n      if (stack.current) {\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\n\nSplashScreen.hideAsync = function () {\n  forceHideAsync();\n  globalStack.length = 0;\n};\n\nvar _userControlledAutoHideEnabled = false;\nvar _preventAutoHideAsyncInvoked = false;\nexport var _internal_preventAutoHideAsync = function _internal_preventAutoHideAsync() {\n  var _ErrorUtils;\n\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n\n  _preventAutoHideAsyncInvoked = true;\n\n  if (Platform.OS !== \"web\" && (_ErrorUtils = ErrorUtils) != null && _ErrorUtils.getGlobalHandler) {\n    var originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler(function (error, isFatal) {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n\n  SplashModule.preventAutoHideAsync();\n};\nexport var _internal_maybeHideAsync = function _internal_maybeHideAsync() {\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n\n  SplashScreen.hideAsync();\n};\n\nfunction forceHideAsync() {\n  return _forceHideAsync.apply(this, arguments);\n}\n\nfunction _forceHideAsync() {\n  _forceHideAsync = _asyncToGenerator(function* () {\n    return SplashModule.hideAsync().catch(function (error) {\n      if (_preventAutoHideAsyncInvoked && error.message.includes(\"No native splash screen registered for \")) {\n        return;\n      }\n\n      throw error;\n    });\n  });\n  return _forceHideAsync.apply(this, arguments);\n}\n\nSplashScreen.preventAutoHideAsync = function () {\n  _userControlledAutoHideEnabled = true;\n\n  _internal_preventAutoHideAsync();\n};\n\nSplashScreen._pushEntry = function () {\n  var entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\n\nSplashScreen._popEntry = function (entry) {\n  var index = globalStack.indexOf(entry);\n\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};","map":{"version":3,"names":["SplashModule","nanoid","React","globalStack","SplashScreen","useGlobalSplash","useEffect","console","warn","stack","useRef","current","_pushEntry","_popEntry","hideAsync","forceHideAsync","length","_userControlledAutoHideEnabled","_preventAutoHideAsyncInvoked","_internal_preventAutoHideAsync","Platform","OS","ErrorUtils","getGlobalHandler","originalHandler","setGlobalHandler","error","isFatal","preventAutoHideAsync","_internal_maybeHideAsync","catch","message","includes","entry","push","index","indexOf","splice"],"sources":["C:/Users/hello/OneDrive/Desktop/React-native/canteen-project/client/node_modules/expo-router/src/views/Splash.tsx"],"sourcesContent":["import * as SplashModule from \"expo-splash-screen\";\nimport { nanoid } from \"nanoid/non-secure\";\nimport * as React from \"react\";\nimport { Platform } from \"react-native\";\n\nconst globalStack: string[] = [];\n\n/**\n * A stack based component for keeping the splash screen visible.\n * Useful for stacked requests that need to be completed before the app is ready.\n * After all instances have been unmounted, the splash screen will be hidden.\n *\n * @example\n * ```tsx\n * function App() {\n *   const [isLoading, setIsLoading] = React.useState(true);\n *\n *   if (isLoading) {\n *     return <SplashScreen />\n *   }\n *\n *   return <Text>Ready!</Text>\n * }\n * ```\n */\nexport function SplashScreen() {\n  useGlobalSplash();\n  React.useEffect(() => {\n    console.warn(\n      \"The <SplashScreen /> component is deprecated. Use `SplashScreen.preventAutoHideAsync()` and `SplashScreen.hideAsync` from `expo-router` instead.\"\n    );\n  }, []);\n  return null;\n}\n\nfunction useGlobalSplash() {\n  const stack = React.useRef<string | null>(null);\n\n  React.useEffect(() => {\n    // Create a stack entry on component mount\n    stack.current = SplashScreen._pushEntry();\n    return () => {\n      if (stack.current) {\n        // Update on component unmount\n        SplashScreen._popEntry(stack.current);\n      }\n    };\n  }, []);\n}\n\nSplashScreen.hideAsync = () => {\n  forceHideAsync();\n  globalStack.length = 0;\n};\n\nlet _userControlledAutoHideEnabled = false;\nlet _preventAutoHideAsyncInvoked = false;\n\n// Expo Router uses this internal method to ensure that we can detect if the user\n// has explicitly opted into preventing the splash screen from hiding. This means\n// they will also explicitly hide it. If they don't, we will hide it for them after\n// the navigation render completes.\nexport const _internal_preventAutoHideAsync = () => {\n  // Memoize, this should only be called once.\n  if (_preventAutoHideAsyncInvoked) {\n    return;\n  }\n  _preventAutoHideAsyncInvoked = true;\n  // Append error handling to ensure any uncaught exceptions result in the splash screen being hidden.\n  if (Platform.OS !== \"web\" && ErrorUtils?.getGlobalHandler) {\n    const originalHandler = ErrorUtils.getGlobalHandler();\n    ErrorUtils.setGlobalHandler((error, isFatal) => {\n      SplashScreen.hideAsync();\n      originalHandler(error, isFatal);\n    });\n  }\n  SplashModule.preventAutoHideAsync();\n};\n\nexport const _internal_maybeHideAsync = () => {\n  // If the user has explicitly opted into preventing the splash screen from hiding,\n  // we should not hide it for them. This is often used for animated splash screens.\n  if (_userControlledAutoHideEnabled) {\n    return;\n  }\n  SplashScreen.hideAsync();\n};\n\nasync function forceHideAsync() {\n  return SplashModule.hideAsync().catch((error: any) => {\n    // Hide this very unfortunate error.\n    if (\n      // Only throw the error is something unexpected happened.\n      _preventAutoHideAsyncInvoked &&\n      error.message.includes(\"No native splash screen registered for \")\n    ) {\n      return;\n    }\n    throw error;\n  });\n}\n\nSplashScreen.preventAutoHideAsync = () => {\n  _userControlledAutoHideEnabled = true;\n  _internal_preventAutoHideAsync();\n};\n\nSplashScreen._pushEntry = (): any => {\n  const entry = nanoid();\n  globalStack.push(entry);\n  SplashScreen.preventAutoHideAsync();\n  return entry;\n};\n\nSplashScreen._popEntry = (entry: string) => {\n  const index = globalStack.indexOf(entry);\n  if (index !== -1) {\n    globalStack.splice(index, 1);\n  }\n  if (globalStack.length === 0) {\n    SplashScreen.hideAsync();\n  }\n};\n\n// TODO: Add some detection for if the splash screen is visible\n"],"mappings":";AAAA,OAAO,KAAKA,YAAZ,MAA8B,oBAA9B;AACA,SAASC,MAAT,QAAuB,mBAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;;AAGA,IAAMC,WAAqB,GAAG,EAA9B;AAoBA,OAAO,SAASC,YAAT,GAAwB;EAC7BC,eAAe;EACfH,KAAK,CAACI,SAAN,CAAgB,YAAM;IACpBC,OAAO,CAACC,IAAR,CACE,kJADF;EAGD,CAJD,EAIG,EAJH;EAKA,OAAO,IAAP;AACD;;AAED,SAASH,eAAT,GAA2B;EACzB,IAAMI,KAAK,GAAGP,KAAK,CAACQ,MAAN,CAA4B,IAA5B,CAAd;EAEAR,KAAK,CAACI,SAAN,CAAgB,YAAM;IAEpBG,KAAK,CAACE,OAAN,GAAgBP,YAAY,CAACQ,UAAb,EAAhB;IACA,OAAO,YAAM;MACX,IAAIH,KAAK,CAACE,OAAV,EAAmB;QAEjBP,YAAY,CAACS,SAAb,CAAuBJ,KAAK,CAACE,OAA7B;MACD;IACF,CALD;EAMD,CATD,EASG,EATH;AAUD;;AAEDP,YAAY,CAACU,SAAb,GAAyB,YAAM;EAC7BC,cAAc;EACdZ,WAAW,CAACa,MAAZ,GAAqB,CAArB;AACD,CAHD;;AAKA,IAAIC,8BAA8B,GAAG,KAArC;AACA,IAAIC,4BAA4B,GAAG,KAAnC;AAMA,OAAO,IAAMC,8BAA8B,GAAG,SAAjCA,8BAAiC,GAAM;EAAA;;EAElD,IAAID,4BAAJ,EAAkC;IAChC;EACD;;EACDA,4BAA4B,GAAG,IAA/B;;EAEA,IAAIE,QAAQ,CAACC,EAAT,KAAgB,KAAhB,mBAAyBC,UAAzB,aAAyB,YAAYC,gBAAzC,EAA2D;IACzD,IAAMC,eAAe,GAAGF,UAAU,CAACC,gBAAX,EAAxB;IACAD,UAAU,CAACG,gBAAX,CAA4B,UAACC,KAAD,EAAQC,OAAR,EAAoB;MAC9CvB,YAAY,CAACU,SAAb;MACAU,eAAe,CAACE,KAAD,EAAQC,OAAR,CAAf;IACD,CAHD;EAID;;EACD3B,YAAY,CAAC4B,oBAAb;AACD,CAfM;AAiBP,OAAO,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,GAAM;EAG5C,IAAIZ,8BAAJ,EAAoC;IAClC;EACD;;EACDb,YAAY,CAACU,SAAb;AACD,CAPM;;SASQC,c;;;;;sCAAf,aAAgC;IAC9B,OAAOf,YAAY,CAACc,SAAb,GAAyBgB,KAAzB,CAA+B,UAACJ,KAAD,EAAgB;MAEpD,IAEER,4BAA4B,IAC5BQ,KAAK,CAACK,OAAN,CAAcC,QAAd,CAAuB,yCAAvB,CAHF,EAIE;QACA;MACD;;MACD,MAAMN,KAAN;IACD,CAVM,CAAP;EAWD,C;;;;AAEDtB,YAAY,CAACwB,oBAAb,GAAoC,YAAM;EACxCX,8BAA8B,GAAG,IAAjC;;EACAE,8BAA8B;AAC/B,CAHD;;AAKAf,YAAY,CAACQ,UAAb,GAA0B,YAAW;EACnC,IAAMqB,KAAK,GAAGhC,MAAM,EAApB;EACAE,WAAW,CAAC+B,IAAZ,CAAiBD,KAAjB;EACA7B,YAAY,CAACwB,oBAAb;EACA,OAAOK,KAAP;AACD,CALD;;AAOA7B,YAAY,CAACS,SAAb,GAAyB,UAACoB,KAAD,EAAmB;EAC1C,IAAME,KAAK,GAAGhC,WAAW,CAACiC,OAAZ,CAAoBH,KAApB,CAAd;;EACA,IAAIE,KAAK,KAAK,CAAC,CAAf,EAAkB;IAChBhC,WAAW,CAACkC,MAAZ,CAAmBF,KAAnB,EAA0B,CAA1B;EACD;;EACD,IAAIhC,WAAW,CAACa,MAAZ,KAAuB,CAA3B,EAA8B;IAC5BZ,YAAY,CAACU,SAAb;EACD;AACF,CARD"},"metadata":{},"sourceType":"module"}