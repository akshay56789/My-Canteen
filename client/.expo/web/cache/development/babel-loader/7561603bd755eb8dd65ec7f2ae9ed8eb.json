{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nvar _excluded = [\"ErrorBoundary\"],\n    _excluded2 = [\"route\", \"navigation\"],\n    _excluded3 = [\"options\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React from \"react\";\nimport { Route, sortRoutesWithInitial, useRouteNode } from \"./Route\";\nimport EXPO_ROUTER_IMPORT_MODE from \"./import-mode\";\nimport { Screen } from \"./primitives\";\nimport { EmptyRoute } from \"./views/EmptyRoute\";\nimport { SuspenseFallback } from \"./views/SuspenseFallback\";\nimport { Try } from \"./views/Try\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { createElement as _createElement } from \"react\";\n\nfunction getSortedChildren(children, order, initialRouteName) {\n  if (!(order != null && order.length)) {\n    return children.sort(sortRoutesWithInitial(initialRouteName)).map(function (route) {\n      return {\n        route: route,\n        props: {}\n      };\n    });\n  }\n\n  var entries = _toConsumableArray(children);\n\n  var ordered = order.map(function (_ref) {\n    var name = _ref.name,\n        redirect = _ref.redirect,\n        initialParams = _ref.initialParams,\n        listeners = _ref.listeners,\n        options = _ref.options;\n\n    if (!entries.length) {\n      console.warn(\"[Layout children]: Too many screens defined. Route \\\"\" + name + \"\\\" is extraneous.\");\n      return null;\n    }\n\n    var matchIndex = entries.findIndex(function (child) {\n      return child.route === name;\n    });\n\n    if (matchIndex === -1) {\n      console.warn(\"[Layout children]: No route named \\\"\" + name + \"\\\" exists in nested children:\", children.map(function (_ref2) {\n        var route = _ref2.route;\n        return route;\n      }));\n      return null;\n    } else {\n      var match = entries[matchIndex];\n      entries.splice(matchIndex, 1);\n\n      if (redirect) {\n        if (typeof redirect === \"string\") {\n          throw new Error(\"Redirecting to a specific route is not supported yet.\");\n        }\n\n        return null;\n      }\n\n      return {\n        route: match,\n        props: {\n          initialParams: initialParams,\n          listeners: listeners,\n          options: options\n        }\n      };\n    }\n  }).filter(Boolean);\n  ordered.push.apply(ordered, _toConsumableArray(entries.sort(sortRoutesWithInitial(initialRouteName)).map(function (route) {\n    return {\n      route: route,\n      props: {}\n    };\n  })));\n  return ordered;\n}\n\nexport function useSortedScreens(order) {\n  var _node$children;\n\n  var node = useRouteNode();\n  var sorted = node != null && (_node$children = node.children) != null && _node$children.length ? getSortedChildren(node.children, order, node.initialRouteName) : [];\n  return React.useMemo(function () {\n    return sorted.map(function (value) {\n      return routeToScreen(value.route, value.props);\n    });\n  }, [sorted]);\n}\n\nfunction fromImport(_ref3) {\n  var ErrorBoundary = _ref3.ErrorBoundary,\n      component = _objectWithoutProperties(_ref3, _excluded);\n\n  if (ErrorBoundary) {\n    return {\n      default: React.forwardRef(function (props, ref) {\n        var children = React.createElement(component.default, _objectSpread(_objectSpread({}, props), {}, {\n          ref: ref\n        }));\n        return _jsx(Try, {\n          catch: ErrorBoundary,\n          children: children\n        });\n      })\n    };\n  }\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof component.default === \"object\" && component.default && Object.keys(component.default).length === 0) {\n      return {\n        default: EmptyRoute\n      };\n    }\n  }\n\n  return {\n    default: component.default || EmptyRoute\n  };\n}\n\nfunction fromLoadedRoute(res) {\n  if (!(res instanceof Promise)) {\n    return fromImport(res);\n  }\n\n  return res.then(fromImport);\n}\n\nvar qualifiedStore = new WeakMap();\nexport function getQualifiedRouteComponent(value) {\n  if (qualifiedStore.has(value)) {\n    return qualifiedStore.get(value);\n  }\n\n  var getLoadable;\n\n  if (EXPO_ROUTER_IMPORT_MODE === \"lazy\") {\n    var AsyncComponent = React.lazy(_asyncToGenerator(function* () {\n      var res = value.loadRoute();\n      return fromLoadedRoute(res);\n    }));\n\n    getLoadable = function getLoadable(props, ref) {\n      return _jsx(React.Suspense, {\n        fallback: _jsx(SuspenseFallback, {\n          route: value\n        }),\n        children: _jsx(AsyncComponent, _objectSpread({}, _objectSpread(_objectSpread({}, props), {}, {\n          ref: ref,\n          segment: value.route\n        })))\n      });\n    };\n  } else {\n    var SyncComponent = React.forwardRef(function (props, ref) {\n      var res = value.loadRoute();\n      var Component = fromImport(res).default;\n      return _jsx(Component, _objectSpread(_objectSpread({}, props), {}, {\n        ref: ref\n      }));\n    });\n\n    getLoadable = function getLoadable(props, ref) {\n      return _jsx(SyncComponent, _objectSpread({}, _objectSpread(_objectSpread({}, props), {}, {\n        ref: ref,\n        segment: value.route\n      })));\n    };\n  }\n\n  var QualifiedRoute = React.forwardRef(function (_ref5, ref) {\n    var route = _ref5.route,\n        navigation = _ref5.navigation,\n        props = _objectWithoutProperties(_ref5, _excluded2);\n\n    var loadable = getLoadable(props, ref);\n    return _jsx(Route, {\n      node: value,\n      children: loadable\n    });\n  });\n  QualifiedRoute.displayName = \"Route(\" + value.route + \")\";\n  qualifiedStore.set(value, QualifiedRoute);\n  return QualifiedRoute;\n}\nexport function createGetIdForRoute(route) {\n  var _route$dynamic;\n\n  if (!((_route$dynamic = route.dynamic) != null && _route$dynamic.length)) {\n    return undefined;\n  }\n\n  return function (_ref6) {\n    var _route$dynamic2;\n\n    var params = _ref6.params;\n\n    var getPreferredId = function getPreferredId(segment) {\n      var preferredId = params == null ? void 0 : params[segment.name];\n\n      if (preferredId) {\n        if (!Array.isArray(preferredId)) {\n          return preferredId;\n        } else if (preferredId.length) {\n          return preferredId.join(\"/\");\n        }\n      }\n\n      return segment.deep ? \"[...\" + segment.name + \"]\" : \"[\" + segment.name + \"]\";\n    };\n\n    return (_route$dynamic2 = route.dynamic) == null ? void 0 : _route$dynamic2.map(function (segment) {\n      return getPreferredId(segment);\n    }).join(\"/\");\n  };\n}\n\nfunction routeToScreen(route) {\n  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _options = _ref7.options,\n      props = _objectWithoutProperties(_ref7, _excluded3);\n\n  return _createElement(Screen, _objectSpread(_objectSpread({\n    getId: createGetIdForRoute(route)\n  }, props), {}, {\n    name: route.route,\n    key: route.route,\n    options: function options(args) {\n      var _route$loadRoute;\n\n      var staticOptions = route.generated ? (_route$loadRoute = route.loadRoute()) == null ? void 0 : _route$loadRoute.getNavOptions : null;\n      var staticResult = typeof staticOptions === \"function\" ? staticOptions(args) : staticOptions;\n      var dynamicResult = typeof _options === \"function\" ? _options == null ? void 0 : _options(args) : _options;\n\n      var output = _objectSpread(_objectSpread({}, staticResult), dynamicResult);\n\n      if (route.generated) {\n        output.tabBarButton = function () {\n          return null;\n        };\n\n        output.drawerItemStyle = {\n          height: 0,\n          display: \"none\"\n        };\n      }\n\n      return output;\n    },\n    getComponent: function getComponent() {\n      return getQualifiedRouteComponent(route);\n    }\n  }));\n}","map":{"version":3,"names":["React","Route","sortRoutesWithInitial","useRouteNode","EXPO_ROUTER_IMPORT_MODE","Screen","EmptyRoute","SuspenseFallback","Try","getSortedChildren","children","order","initialRouteName","length","sort","map","route","props","entries","ordered","name","redirect","initialParams","listeners","options","console","warn","matchIndex","findIndex","child","match","splice","Error","filter","Boolean","push","useSortedScreens","node","sorted","useMemo","value","routeToScreen","fromImport","ErrorBoundary","component","default","forwardRef","ref","createElement","process","env","NODE_ENV","Object","keys","fromLoadedRoute","res","Promise","then","qualifiedStore","WeakMap","getQualifiedRouteComponent","has","get","getLoadable","AsyncComponent","lazy","loadRoute","segment","SyncComponent","Component","QualifiedRoute","navigation","loadable","displayName","set","createGetIdForRoute","dynamic","undefined","params","getPreferredId","preferredId","Array","isArray","join","deep","args","staticOptions","generated","getNavOptions","staticResult","dynamicResult","output","tabBarButton","drawerItemStyle","height","display"],"sources":["C:/Users/hello/OneDrive/Desktop/React-native/canteen-project/client/node_modules/expo-router/src/useScreens.tsx"],"sourcesContent":["import React from \"react\";\n\nimport {\n  DynamicConvention,\n  LoadedRoute,\n  Route,\n  RouteNode,\n  sortRoutesWithInitial,\n  useRouteNode,\n} from \"./Route\";\nimport EXPO_ROUTER_IMPORT_MODE from \"./import-mode\";\nimport { Screen } from \"./primitives\";\nimport { EmptyRoute } from \"./views/EmptyRoute\";\nimport { SuspenseFallback } from \"./views/SuspenseFallback\";\nimport { Try } from \"./views/Try\";\n\nexport type ScreenProps<\n  TOptions extends Record<string, any> = Record<string, any>\n> = {\n  /** Name is required when used inside a Layout component. */\n  name?: string;\n  /**\n   * Redirect to the nearest sibling route.\n   * If all children are redirect={true}, the layout will render `null` as there are no children to render.\n   */\n  redirect?: boolean;\n  initialParams?: { [key: string]: any };\n  options?: TOptions;\n\n  // TODO: types\n  listeners?: any;\n};\n\nfunction getSortedChildren(\n  children: RouteNode[],\n  order?: ScreenProps[],\n  initialRouteName?: string\n): { route: RouteNode; props: Partial<ScreenProps> }[] {\n  if (!order?.length) {\n    return children\n      .sort(sortRoutesWithInitial(initialRouteName))\n      .map((route) => ({ route, props: {} }));\n  }\n  const entries = [...children];\n\n  const ordered = order\n    .map(({ name, redirect, initialParams, listeners, options }) => {\n      if (!entries.length) {\n        console.warn(\n          `[Layout children]: Too many screens defined. Route \"${name}\" is extraneous.`\n        );\n        return null;\n      }\n      const matchIndex = entries.findIndex((child) => child.route === name);\n      if (matchIndex === -1) {\n        console.warn(\n          `[Layout children]: No route named \"${name}\" exists in nested children:`,\n          children.map(({ route }) => route)\n        );\n        return null;\n      } else {\n        // Get match and remove from entries\n        const match = entries[matchIndex];\n        entries.splice(matchIndex, 1);\n\n        // Ensure to return null after removing from entries.\n        if (redirect) {\n          if (typeof redirect === \"string\") {\n            throw new Error(\n              `Redirecting to a specific route is not supported yet.`\n            );\n          }\n          return null;\n        }\n\n        return { route: match, props: { initialParams, listeners, options } };\n      }\n    })\n    .filter(Boolean) as {\n    route: RouteNode;\n    props: Partial<ScreenProps>;\n  }[];\n\n  // Add any remaining children\n  ordered.push(\n    ...entries\n      .sort(sortRoutesWithInitial(initialRouteName))\n      .map((route) => ({ route, props: {} }))\n  );\n\n  return ordered;\n}\n\n/**\n * @returns React Navigation screens sorted by the `route` property.\n */\nexport function useSortedScreens(order: ScreenProps[]): React.ReactNode[] {\n  const node = useRouteNode();\n\n  const sorted = node?.children?.length\n    ? getSortedChildren(node.children, order, node.initialRouteName)\n    : [];\n  return React.useMemo(\n    () => sorted.map((value) => routeToScreen(value.route, value.props)),\n    [sorted]\n  );\n}\n\nfunction fromImport({ ErrorBoundary, ...component }: LoadedRoute) {\n  if (ErrorBoundary) {\n    return {\n      default: React.forwardRef((props: any, ref: any) => {\n        const children = React.createElement(component.default, {\n          ...props,\n          ref,\n        });\n        return <Try catch={ErrorBoundary}>{children}</Try>;\n      }),\n    };\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    if (\n      typeof component.default === \"object\" &&\n      component.default &&\n      Object.keys(component.default).length === 0\n    ) {\n      return { default: EmptyRoute };\n    }\n  }\n  return { default: component.default || EmptyRoute };\n}\n\nfunction fromLoadedRoute(res: LoadedRoute) {\n  if (!(res instanceof Promise)) {\n    return fromImport(res);\n  }\n\n  return res.then(fromImport);\n}\n\n// TODO: Maybe there's a more React-y way to do this?\n// Without this store, the process enters a recursive loop.\nconst qualifiedStore = new WeakMap<RouteNode, React.ComponentType<any>>();\n\n/** Wrap the component with various enhancements and add access to child routes. */\nexport function getQualifiedRouteComponent(value: RouteNode) {\n  if (qualifiedStore.has(value)) {\n    return qualifiedStore.get(value)!;\n  }\n\n  let getLoadable: (props: any, ref: any) => JSX.Element;\n\n  // TODO: This ensures sync doesn't use React.lazy, but it's not ideal.\n  if (EXPO_ROUTER_IMPORT_MODE === \"lazy\") {\n    const AsyncComponent = React.lazy(async () => {\n      const res = value.loadRoute();\n      return fromLoadedRoute(res) as Promise<{\n        default: React.ComponentType<any>;\n      }>;\n    });\n    getLoadable = (props: any, ref: any) => (\n      <React.Suspense fallback={<SuspenseFallback route={value} />}>\n        <AsyncComponent\n          {...{\n            ...props,\n            ref,\n            // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`\n            // the intention is to make it possible to deduce shared routes.\n            segment: value.route,\n          }}\n        />\n      </React.Suspense>\n    );\n  } else {\n    const SyncComponent = React.forwardRef((props, ref) => {\n      const res = value.loadRoute();\n      const Component = fromImport(res).default;\n      return <Component {...props} ref={ref} />;\n    });\n\n    getLoadable = (props: any, ref: any) => (\n      <SyncComponent\n        {...{\n          ...props,\n          ref,\n          // Expose the template segment path, e.g. `(home)`, `[foo]`, `index`\n          // the intention is to make it possible to deduce shared routes.\n          segment: value.route,\n        }}\n      />\n    );\n  }\n\n  const QualifiedRoute = React.forwardRef(\n    (\n      {\n        // Remove these React Navigation props to\n        // enforce usage of expo-router hooks (where the query params are correct).\n        route,\n        navigation,\n\n        // Pass all other props to the component\n        ...props\n      }: any,\n      ref: any\n    ) => {\n      const loadable = getLoadable(props, ref);\n\n      return <Route node={value}>{loadable}</Route>;\n    }\n  );\n\n  QualifiedRoute.displayName = `Route(${value.route})`;\n\n  qualifiedStore.set(value, QualifiedRoute);\n  return QualifiedRoute;\n}\n\n/** @returns a function which provides a screen id that matches the dynamic route name in params. */\nexport function createGetIdForRoute(\n  route: Pick<RouteNode, \"dynamic\" | \"route\">\n) {\n  if (!route.dynamic?.length) {\n    return undefined;\n  }\n  return ({ params }: { params?: Record<string, any> }) => {\n    const getPreferredId = (segment: DynamicConvention) => {\n      // Params can be undefined when there are no params in the route.\n      const preferredId = params?.[segment.name];\n      // If the route has a dynamic segment, use the matching parameter\n      // as the screen id. This enables pushing a screen like `/[user]` multiple times\n      // when the user is different.\n      if (preferredId) {\n        if (!Array.isArray(preferredId)) {\n          return preferredId;\n        } else if (preferredId.length) {\n          // Deep dynamic routes will return as an array, so we'll join them to create a\n          // fully qualified string.\n          return preferredId.join(\"/\");\n        }\n        // Empty arrays...\n      }\n      return segment.deep ? `[...${segment.name}]` : `[${segment.name}]`;\n    };\n    return route.dynamic?.map((segment) => getPreferredId(segment)).join(\"/\");\n  };\n}\n\nfunction routeToScreen(\n  route: RouteNode,\n  { options, ...props }: Partial<ScreenProps> = {}\n) {\n  return (\n    <Screen\n      // Users can override the screen getId function.\n      getId={createGetIdForRoute(route)}\n      {...props}\n      name={route.route}\n      key={route.route}\n      options={(args) => {\n        // Only eager load generated components\n        const staticOptions = route.generated\n          ? route.loadRoute()?.getNavOptions\n          : null;\n        const staticResult =\n          typeof staticOptions === \"function\"\n            ? staticOptions(args)\n            : staticOptions;\n        const dynamicResult =\n          typeof options === \"function\" ? options?.(args) : options;\n        const output = {\n          ...staticResult,\n          ...dynamicResult,\n        };\n\n        // Prevent generated screens from showing up in the tab bar.\n        if (route.generated) {\n          output.tabBarButton = () => null;\n          // TODO: React Navigation doesn't provide a way to prevent rendering the drawer item.\n          output.drawerItemStyle = { height: 0, display: \"none\" };\n        }\n\n        return output;\n      }}\n      getComponent={() => getQualifiedRouteComponent(route)}\n    />\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}