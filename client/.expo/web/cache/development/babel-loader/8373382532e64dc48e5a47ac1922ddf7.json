{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"@babel/runtime/helpers/toConsumableArray\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseLogBoxLog = exports.parseLogBoxException = exports.parseComponentStack = exports.parseInterpolation = void 0;\n\nvar UTFSequence_1 = __importDefault(require(\"react-native/Libraries/UTFSequence\"));\n\nvar parseErrorStack_1 = __importDefault(require(\"../modules/parseErrorStack\"));\n\nvar stringifySafe_1 = __importDefault(require(\"../modules/stringifySafe\"));\n\nvar BABEL_TRANSFORM_ERROR_FORMAT = /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nvar BABEL_CODE_FRAME_ERROR_FORMAT = /^(?:TransformError )?(?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*):? (?:(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*?)(\\/(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+?)\\n([ >]{2}[\\t-\\r 0-9\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]+ \\|(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+|\\x1B(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar METRO_ERROR_FORMAT = /^(?:InternalError Metro has encountered an error:) ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*): ((?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*) \\(([0-9]+):([0-9]+)\\)\\n\\n((?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)/;\nvar SUBSTITUTION = UTFSequence_1.default.BOM + \"%s\";\n\nfunction parseInterpolation(args) {\n  var categoryParts = [];\n  var contentParts = [];\n  var substitutionOffsets = [];\n\n  var remaining = _toConsumableArray(args);\n\n  if (typeof remaining[0] === \"string\") {\n    var formatString = String(remaining.shift());\n    var formatStringParts = formatString.split(\"%s\");\n    var substitutionCount = formatStringParts.length - 1;\n    var substitutions = remaining.splice(0, substitutionCount);\n    var categoryString = \"\";\n    var contentString = \"\";\n    var substitutionIndex = 0;\n\n    for (var formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          var substitution = typeof substitutions[substitutionIndex] === \"string\" ? substitutions[substitutionIndex] : (0, stringifySafe_1.default)(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length\n          });\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length\n          });\n          categoryString += \"%s\";\n          contentString += \"%s\";\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  var remainingArgs = remaining.map(function (arg) {\n    return typeof arg === \"string\" ? arg : (0, stringifySafe_1.default)(arg);\n  });\n  categoryParts.push.apply(categoryParts, _toConsumableArray(remainingArgs));\n  contentParts.push.apply(contentParts, _toConsumableArray(remainingArgs));\n  return {\n    category: categoryParts.join(\" \"),\n    message: {\n      content: contentParts.join(\" \"),\n      substitutions: substitutionOffsets\n    }\n  };\n}\n\nexports.parseInterpolation = parseInterpolation;\n\nfunction isComponentStack(consoleArgument) {\n  var isOldComponentStackFormat = / {4}in/.test(consoleArgument);\n  var isNewComponentStackFormat = / {4}at/.test(consoleArgument);\n  var isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\n  return isOldComponentStackFormat || isNewComponentStackFormat || isNewJSCComponentStackFormat;\n}\n\nfunction parseComponentStack(message) {\n  var stack = (0, parseErrorStack_1.default)(message);\n\n  if (stack && stack.length > 0) {\n    return stack.map(function (frame) {\n      return {\n        content: frame.methodName,\n        collapse: frame.collapse || false,\n        fileName: frame.file == null ? \"unknown\" : frame.file,\n        location: {\n          column: frame.column == null ? -1 : frame.column,\n          row: frame.lineNumber == null ? -1 : frame.lineNumber\n        }\n      };\n    });\n  }\n\n  return message.split(/\\n {4}in /g).map(function (s) {\n    if (!s) {\n      return null;\n    }\n\n    var match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n\n    if (!match) {\n      return null;\n    }\n\n    var _match$slice = match.slice(1),\n        _match$slice2 = _slicedToArray(_match$slice, 3),\n        content = _match$slice2[0],\n        fileName = _match$slice2[1],\n        row = _match$slice2[2];\n\n    return {\n      content: content,\n      fileName: fileName,\n      location: {\n        column: -1,\n        row: parseInt(row, 10)\n      }\n    };\n  }).filter(Boolean);\n}\n\nexports.parseComponentStack = parseComponentStack;\n\nfunction parseLogBoxException(error) {\n  var message = error.originalMessage != null ? error.originalMessage : \"Unknown\";\n  var metroInternalError = message.match(METRO_ERROR_FORMAT);\n\n  if (metroInternalError) {\n    var _metroInternalError$s = metroInternalError.slice(1),\n        _metroInternalError$s2 = _slicedToArray(_metroInternalError$s, 5),\n        content = _metroInternalError$s2[0],\n        fileName = _metroInternalError$s2[1],\n        row = _metroInternalError$s2[2],\n        column = _metroInternalError$s2[3],\n        codeFrame = _metroInternalError$s2[4];\n\n    return {\n      level: \"fatal\",\n      type: \"Metro Error\",\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10)\n        },\n        content: codeFrame\n      },\n      message: {\n        content: content,\n        substitutions: []\n      },\n      category: fileName + \"-\" + row + \"-\" + column\n    };\n  }\n\n  var babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n\n  if (babelTransformError) {\n    var _babelTransformError$ = babelTransformError.slice(1),\n        _babelTransformError$2 = _slicedToArray(_babelTransformError$, 5),\n        _fileName = _babelTransformError$2[0],\n        _content = _babelTransformError$2[1],\n        _row = _babelTransformError$2[2],\n        _column = _babelTransformError$2[3],\n        _codeFrame = _babelTransformError$2[4];\n\n    return {\n      level: \"syntax\",\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName,\n        location: {\n          row: parseInt(_row, 10),\n          column: parseInt(_column, 10)\n        },\n        content: _codeFrame\n      },\n      message: {\n        content: _content,\n        substitutions: []\n      },\n      category: _fileName + \"-\" + _row + \"-\" + _column\n    };\n  }\n\n  var babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n\n  if (babelCodeFrameError) {\n    var _babelCodeFrameError$ = babelCodeFrameError.slice(1),\n        _babelCodeFrameError$2 = _slicedToArray(_babelCodeFrameError$, 3),\n        _fileName2 = _babelCodeFrameError$2[0],\n        _content2 = _babelCodeFrameError$2[1],\n        _codeFrame2 = _babelCodeFrameError$2[2];\n\n    return {\n      level: \"syntax\",\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName: _fileName2,\n        location: null,\n        content: _codeFrame2\n      },\n      message: {\n        content: _content2,\n        substitutions: []\n      },\n      category: _fileName2 + \"-\" + 1 + \"-\" + 1\n    };\n  }\n\n  if (message.match(/^TransformError /)) {\n    return {\n      level: \"syntax\",\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: []\n      },\n      category: message\n    };\n  }\n\n  var componentStack = error.componentStack;\n\n  if (error.isFatal || error.isComponentError) {\n    return _objectSpread({\n      level: \"fatal\",\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: componentStack != null ? parseComponentStack(componentStack) : []\n    }, parseInterpolation([message]));\n  }\n\n  if (componentStack != null) {\n    return _objectSpread({\n      level: \"error\",\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack)\n    }, parseInterpolation([message]));\n  }\n\n  return _objectSpread({\n    level: \"error\",\n    stack: error.stack,\n    isComponentError: error.isComponentError\n  }, parseLogBoxLog([message]));\n}\n\nexports.parseLogBoxException = parseLogBoxException;\n\nfunction parseLogBoxLog(args) {\n  var message = args[0];\n  var argsWithoutComponentStack = [];\n  var componentStack = [];\n\n  if (typeof message === \"string\" && message.slice(-2) === \"%s\" && args.length > 0) {\n    var lastArg = args[args.length - 1];\n\n    if (typeof lastArg === \"string\" && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n\n  if (componentStack.length === 0) {\n    for (var arg of args) {\n      if (typeof arg === \"string\" && isComponentStack(arg)) {\n        var messageEndIndex = arg.search(/\\n {4}(in|at) /);\n\n        if (messageEndIndex < 0) {\n          messageEndIndex = arg.search(/\\n/);\n        }\n\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return _objectSpread(_objectSpread({}, parseInterpolation(argsWithoutComponentStack)), {}, {\n    componentStack: componentStack\n  });\n}\n\nexports.parseLogBoxLog = parseLogBoxLog;","map":{"version":3,"sources":["../../../src/error-overlay/Data/parseLogBoxLog.tsx"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Evan Bacon.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// @ts-expect-error\nimport UTFSequence from \"react-native/Libraries/UTFSequence\";\n\nimport parseErrorStack from \"../modules/parseErrorStack\";\nimport stringifySafe from \"../modules/stringifySafe\";\nimport type { LogBoxLogData } from \"./LogBoxLog\";\ntype ExceptionData = any;\n\nconst BABEL_TRANSFORM_ERROR_FORMAT =\n  /^(?:TransformError )?(?:SyntaxError: |ReferenceError: )(.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/;\nconst BABEL_CODE_FRAME_ERROR_FORMAT =\n  /^(?:TransformError )?(?:.*):? (?:.*?)(\\/.*): ([\\s\\S]+?)\\n([ >]{2}[\\d\\s]+ \\|[\\s\\S]+|\\u{001b}[\\s\\S]+)/u;\nconst METRO_ERROR_FORMAT =\n  /^(?:InternalError Metro has encountered an error:) (.*): (.*) \\((\\d+):(\\d+)\\)\\n\\n([\\s\\S]+)/u;\n\nexport type ExtendedExceptionData = ExceptionData & {\n  isComponentError: boolean;\n  [key: string]: any;\n};\nexport type Category = string;\nexport type CodeFrame = {\n  content: string;\n  location?: {\n    row: number;\n    column: number;\n    [key: string]: any;\n  } | null;\n  fileName: string;\n\n  // TODO: When React switched to using call stack frames,\n  // we gained the ability to use the collapse flag, but\n  // it is not integrated into the LogBox UI.\n  collapse?: boolean;\n};\n\nexport type Message = {\n  content: string;\n  substitutions: {\n    length: number;\n    offset: number;\n  }[];\n};\n\nexport type ComponentStack = CodeFrame[];\n\nconst SUBSTITUTION = UTFSequence.BOM + \"%s\";\n\nexport function parseInterpolation(args: readonly any[]): {\n  category: Category;\n  message: Message;\n} {\n  const categoryParts: string[] = [];\n  const contentParts: string[] = [];\n  const substitutionOffsets: { length: number; offset: number }[] = [];\n\n  const remaining = [...args];\n  if (typeof remaining[0] === \"string\") {\n    const formatString = String(remaining.shift());\n    const formatStringParts = formatString.split(\"%s\");\n    const substitutionCount = formatStringParts.length - 1;\n    const substitutions = remaining.splice(0, substitutionCount);\n\n    let categoryString = \"\";\n    let contentString = \"\";\n\n    let substitutionIndex = 0;\n    for (const formatStringPart of formatStringParts) {\n      categoryString += formatStringPart;\n      contentString += formatStringPart;\n\n      if (substitutionIndex < substitutionCount) {\n        if (substitutionIndex < substitutions.length) {\n          // Don't stringify a string type.\n          // It adds quotation mark wrappers around the string,\n          // which causes the LogBox to look odd.\n          const substitution =\n            typeof substitutions[substitutionIndex] === \"string\"\n              ? substitutions[substitutionIndex]\n              : stringifySafe(substitutions[substitutionIndex]);\n          substitutionOffsets.push({\n            length: substitution.length,\n            offset: contentString.length,\n          });\n\n          categoryString += SUBSTITUTION;\n          contentString += substitution;\n        } else {\n          substitutionOffsets.push({\n            length: 2,\n            offset: contentString.length,\n          });\n\n          categoryString += \"%s\";\n          contentString += \"%s\";\n        }\n\n        substitutionIndex++;\n      }\n    }\n\n    categoryParts.push(categoryString);\n    contentParts.push(contentString);\n  }\n\n  const remainingArgs = remaining.map((arg) => {\n    // Don't stringify a string type.\n    // It adds quotation mark wrappers around the string,\n    // which causes the LogBox to look odd.\n    return typeof arg === \"string\" ? arg : stringifySafe(arg);\n  });\n  categoryParts.push(...remainingArgs);\n  contentParts.push(...remainingArgs);\n\n  return {\n    category: categoryParts.join(\" \"),\n    message: {\n      content: contentParts.join(\" \"),\n      substitutions: substitutionOffsets,\n    },\n  };\n}\n\nfunction isComponentStack(consoleArgument: string) {\n  const isOldComponentStackFormat = / {4}in/.test(consoleArgument);\n  const isNewComponentStackFormat = / {4}at/.test(consoleArgument);\n  const isNewJSCComponentStackFormat = /@.*\\n/.test(consoleArgument);\n\n  return (\n    isOldComponentStackFormat ||\n    isNewComponentStackFormat ||\n    isNewJSCComponentStackFormat\n  );\n}\n\nexport function parseComponentStack(message: string): ComponentStack {\n  // In newer versions of React, the component stack is formatted as a call stack frame.\n  // First try to parse the component stack as a call stack frame, and if that doesn't\n  // work then we'll fallback to the old custom component stack format parsing.\n  const stack = parseErrorStack(message);\n  if (stack && stack.length > 0) {\n    return stack.map((frame) => ({\n      content: frame.methodName,\n      collapse: frame.collapse || false,\n      fileName: frame.file == null ? \"unknown\" : frame.file,\n      location: {\n        column: frame.column == null ? -1 : frame.column,\n        row: frame.lineNumber == null ? -1 : frame.lineNumber,\n      },\n    }));\n  }\n\n  return message\n    .split(/\\n {4}in /g)\n    .map((s) => {\n      if (!s) {\n        return null;\n      }\n      const match = s.match(/(.*) \\(at (.*\\.js):([\\d]+)\\)/);\n      if (!match) {\n        return null;\n      }\n\n      const [content, fileName, row] = match.slice(1);\n      return {\n        content,\n        fileName,\n        location: { column: -1, row: parseInt(row, 10) },\n      };\n    })\n    .filter(Boolean) as ComponentStack;\n}\n\nexport function parseLogBoxException(\n  error: ExtendedExceptionData\n): LogBoxLogData {\n  const message =\n    error.originalMessage != null ? error.originalMessage : \"Unknown\";\n\n  const metroInternalError = message.match(METRO_ERROR_FORMAT);\n  if (metroInternalError) {\n    const [content, fileName, row, column, codeFrame] =\n      metroInternalError.slice(1);\n\n    return {\n      level: \"fatal\",\n      type: \"Metro Error\",\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelTransformError = message.match(BABEL_TRANSFORM_ERROR_FORMAT);\n  if (babelTransformError) {\n    // Transform errors are thrown from inside the Babel transformer.\n    const [fileName, content, row, column, codeFrame] =\n      babelTransformError.slice(1);\n\n    return {\n      level: \"syntax\",\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: {\n          row: parseInt(row, 10),\n          column: parseInt(column, 10),\n        },\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${row}-${column}`,\n    };\n  }\n\n  const babelCodeFrameError = message.match(BABEL_CODE_FRAME_ERROR_FORMAT);\n\n  if (babelCodeFrameError) {\n    // Codeframe errors are thrown from any use of buildCodeFrameError.\n    const [fileName, content, codeFrame] = babelCodeFrameError.slice(1);\n    return {\n      level: \"syntax\",\n      stack: [],\n      isComponentError: false,\n      componentStack: [],\n      codeFrame: {\n        fileName,\n        location: null, // We are not given the location.\n        content: codeFrame,\n      },\n      message: {\n        content,\n        substitutions: [],\n      },\n      category: `${fileName}-${1}-${1}`,\n    };\n  }\n\n  if (message.match(/^TransformError /)) {\n    return {\n      level: \"syntax\",\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: [],\n      message: {\n        content: message,\n        substitutions: [],\n      },\n      category: message,\n    };\n  }\n\n  const componentStack = error.componentStack;\n  if (error.isFatal || error.isComponentError) {\n    return {\n      level: \"fatal\",\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack:\n        componentStack != null ? parseComponentStack(componentStack) : [],\n      ...parseInterpolation([message]),\n    };\n  }\n\n  if (componentStack != null) {\n    // It is possible that console errors have a componentStack.\n    return {\n      level: \"error\",\n      stack: error.stack,\n      isComponentError: error.isComponentError,\n      componentStack: parseComponentStack(componentStack),\n      ...parseInterpolation([message]),\n    };\n  }\n\n  // Most `console.error` calls won't have a componentStack. We parse them like\n  // regular logs which have the component stack burried in the message.\n  return {\n    level: \"error\",\n    stack: error.stack,\n    isComponentError: error.isComponentError,\n    ...parseLogBoxLog([message]),\n  };\n}\n\nexport function parseLogBoxLog(args: readonly any[]): {\n  componentStack: ComponentStack;\n  category: Category;\n  message: Message;\n} {\n  const message = args[0];\n  let argsWithoutComponentStack: any[] = [];\n  let componentStack: ComponentStack = [];\n\n  // Extract component stack from warnings like \"Some warning%s\".\n  if (\n    typeof message === \"string\" &&\n    message.slice(-2) === \"%s\" &&\n    args.length > 0\n  ) {\n    const lastArg = args[args.length - 1];\n    if (typeof lastArg === \"string\" && isComponentStack(lastArg)) {\n      argsWithoutComponentStack = args.slice(0, -1);\n      argsWithoutComponentStack[0] = message.slice(0, -2);\n      componentStack = parseComponentStack(lastArg);\n    }\n  }\n\n  if (componentStack.length === 0) {\n    // Try finding the component stack elsewhere.\n    for (const arg of args) {\n      if (typeof arg === \"string\" && isComponentStack(arg)) {\n        // Strip out any messages before the component stack.\n        let messageEndIndex = arg.search(/\\n {4}(in|at) /);\n        if (messageEndIndex < 0) {\n          // Handle JSC component stacks.\n          messageEndIndex = arg.search(/\\n/);\n        }\n        if (messageEndIndex > 0) {\n          argsWithoutComponentStack.push(arg.slice(0, messageEndIndex));\n        }\n\n        componentStack = parseComponentStack(arg);\n      } else {\n        argsWithoutComponentStack.push(arg);\n      }\n    }\n  }\n\n  return {\n    ...parseInterpolation(argsWithoutComponentStack),\n    componentStack,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}