{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.withSubscription = exports.observe = exports.isDisabled = exports.setDisabled = exports.addIgnorePatterns = exports.getIgnorePatterns = exports.dismiss = exports.clearErrors = exports.clearWarnings = exports.setSelectedLog = exports.clear = exports.symbolicateLogLazy = exports.retrySymbolicateLogNow = exports.symbolicateLogNow = exports.addException = exports.addLog = exports.isMessageIgnored = exports.isLogBoxErrorMessage = exports.reportUnexpectedLogBoxError = exports.reportLogBoxError = void 0;\n\nvar React = __importStar(require(\"react\"));\n\nvar NativeLogBox_1 = __importDefault(require(\"../modules/NativeLogBox\"));\n\nvar parseErrorStack_1 = __importDefault(require(\"../modules/parseErrorStack\"));\n\nvar LogBoxLog_1 = require(\"./LogBoxLog\");\n\nvar LogContext_1 = require(\"./LogContext\");\n\nvar parseLogBoxLog_1 = require(\"./parseLogBoxLog\");\n\nvar observers = new Set();\nvar ignorePatterns = new Set();\nvar logs = new Set();\nvar updateTimeout = null;\nvar _isDisabled = false;\n\nvar _selectedIndex = -1;\n\nvar LOGBOX_ERROR_MESSAGE = \"An error was thrown when attempting to render log messages via LogBox.\";\n\nfunction getNextState() {\n  return {\n    logs: logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex\n  };\n}\n\nfunction reportLogBoxError(error, componentStack) {\n  var ExceptionsManager = require(\"../modules/ExceptionsManager\");\n\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n\n  ExceptionsManager.handleException(error);\n}\n\nexports.reportLogBoxError = reportLogBoxError;\n\nfunction reportUnexpectedLogBoxError(error, componentStack) {\n  error.message = LOGBOX_ERROR_MESSAGE + \"\\n\\n\" + error.message;\n  return reportLogBoxError(error, componentStack);\n}\n\nexports.reportUnexpectedLogBoxError = reportUnexpectedLogBoxError;\n\nfunction isLogBoxErrorMessage(message) {\n  return typeof message === \"string\" && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexports.isLogBoxErrorMessage = isLogBoxErrorMessage;\n\nfunction isMessageIgnored(message) {\n  for (var pattern of ignorePatterns) {\n    if (pattern instanceof RegExp && pattern.test(message) || typeof pattern === \"string\" && message.includes(pattern)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.isMessageIgnored = isMessageIgnored;\n\nfunction setImmediateShim(callback) {\n  if (!global.setImmediate) {\n    return setTimeout(callback, 0);\n  }\n\n  return global.setImmediate(callback);\n}\n\nfunction handleUpdate() {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediateShim(function () {\n      updateTimeout = null;\n      var nextState = getNextState();\n      observers.forEach(function (_ref) {\n        var observer = _ref.observer;\n        return observer(nextState);\n      });\n    });\n  }\n}\n\nfunction appendNewLog(newLog) {\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  var lastLog = Array.from(logs).pop();\n\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === \"fatal\") {\n    var OPTIMISTIC_WAIT_TIME = 1000;\n\n    var _addPendingLog = function addPendingLog() {\n      logs.add(newLog);\n\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n\n      _addPendingLog = null;\n    };\n\n    var optimisticTimeout = setTimeout(function () {\n      if (_addPendingLog) {\n        _addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n    newLog.symbolicate(\"component\");\n    newLog.symbolicate(\"stack\", function (status) {\n      if (_addPendingLog && status !== \"PENDING\") {\n        _addPendingLog();\n\n        clearTimeout(optimisticTimeout);\n      } else if (status !== \"PENDING\") {\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === \"syntax\") {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nfunction addLog(log) {\n  var errorForStackTrace = new Error();\n  setImmediate(function () {\n    try {\n      var stack = (0, parseErrorStack_1.default)(errorForStackTrace === null || errorForStackTrace === void 0 ? void 0 : errorForStackTrace.stack);\n      appendNewLog(new LogBoxLog_1.LogBoxLog({\n        level: log.level,\n        message: log.message,\n        isComponentError: false,\n        stack: stack,\n        category: log.category,\n        componentStack: log.componentStack\n      }));\n    } catch (error) {\n      reportUnexpectedLogBoxError(error);\n    }\n  });\n}\n\nexports.addLog = addLog;\n\nfunction addException(error) {\n  setImmediate(function () {\n    try {\n      appendNewLog(new LogBoxLog_1.LogBoxLog((0, parseLogBoxLog_1.parseLogBoxException)(error)));\n    } catch (loggingError) {\n      reportUnexpectedLogBoxError(loggingError);\n    }\n  });\n}\n\nexports.addException = addException;\n\nfunction symbolicateLogNow(type, log) {\n  log.symbolicate(type, function () {\n    handleUpdate();\n  });\n}\n\nexports.symbolicateLogNow = symbolicateLogNow;\n\nfunction retrySymbolicateLogNow(type, log) {\n  log.retrySymbolicate(type, function () {\n    handleUpdate();\n  });\n}\n\nexports.retrySymbolicateLogNow = retrySymbolicateLogNow;\n\nfunction symbolicateLogLazy(type, log) {\n  log.symbolicate(type);\n}\n\nexports.symbolicateLogLazy = symbolicateLogLazy;\n\nfunction clear() {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexports.clear = clear;\n\nfunction setSelectedLog(proposedNewIndex) {\n  var oldIndex = _selectedIndex;\n  var newIndex = proposedNewIndex;\n  var logArray = Array.from(logs);\n  var index = logArray.length - 1;\n\n  while (index >= 0) {\n    if (logArray[index].level === \"syntax\") {\n      newIndex = index;\n      break;\n    }\n\n    index -= 1;\n  }\n\n  _selectedIndex = newIndex;\n  handleUpdate();\n\n  if (NativeLogBox_1.default) {\n    setTimeout(function () {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox_1.default.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox_1.default.hide();\n      }\n    }, 0);\n  }\n}\n\nexports.setSelectedLog = setSelectedLog;\n\nfunction clearWarnings() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== \"warn\";\n  });\n\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexports.clearWarnings = clearWarnings;\n\nfunction clearErrors() {\n  var newLogs = Array.from(logs).filter(function (log) {\n    return log.level !== \"error\" && log.level !== \"fatal\";\n  });\n\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexports.clearErrors = clearErrors;\n\nfunction dismiss(log) {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexports.dismiss = dismiss;\n\nfunction getIgnorePatterns() {\n  return Array.from(ignorePatterns);\n}\n\nexports.getIgnorePatterns = getIgnorePatterns;\n\nfunction addIgnorePatterns(patterns) {\n  var existingSize = ignorePatterns.size;\n  patterns.forEach(function (pattern) {\n    if (pattern instanceof RegExp) {\n      for (var existingPattern of ignorePatterns) {\n        if (existingPattern instanceof RegExp && existingPattern.toString() === pattern.toString()) {\n          return;\n        }\n      }\n\n      ignorePatterns.add(pattern);\n    }\n\n    ignorePatterns.add(pattern);\n  });\n\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n\n  logs = new Set(Array.from(logs).filter(function (log) {\n    return !isMessageIgnored(log.message.content);\n  }));\n  handleUpdate();\n}\n\nexports.addIgnorePatterns = addIgnorePatterns;\n\nfunction setDisabled(value) {\n  if (value === _isDisabled) {\n    return;\n  }\n\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexports.setDisabled = setDisabled;\n\nfunction isDisabled() {\n  return _isDisabled;\n}\n\nexports.isDisabled = isDisabled;\n\nfunction observe(observer) {\n  var subscription = {\n    observer: observer\n  };\n  observers.add(subscription);\n  observer(getNextState());\n  return {\n    unsubscribe: function unsubscribe() {\n      observers.delete(subscription);\n    }\n  };\n}\n\nexports.observe = observe;\n\nfunction withSubscription(WrappedComponent) {\n  var LogBoxStateSubscription = function (_React$Component) {\n    _inherits(LogBoxStateSubscription, _React$Component);\n\n    var _super = _createSuper(LogBoxStateSubscription);\n\n    function LogBoxStateSubscription() {\n      var _this;\n\n      _classCallCheck(this, LogBoxStateSubscription);\n\n      _this = _super.apply(this, arguments);\n      _this.state = {\n        logs: new Set(),\n        isDisabled: false,\n        hasError: false,\n        selectedLogIndex: -1\n      };\n\n      _this._handleDismiss = function () {\n        var _this$state = _this.state,\n            selectedLogIndex = _this$state.selectedLogIndex,\n            stateLogs = _this$state.logs;\n        var logsArray = Array.from(stateLogs);\n\n        if (selectedLogIndex != null) {\n          if (logsArray.length - 1 <= 0) {\n            setSelectedLog(-1);\n          } else if (selectedLogIndex >= logsArray.length - 1) {\n            setSelectedLog(selectedLogIndex - 1);\n          }\n\n          dismiss(logsArray[selectedLogIndex]);\n        }\n      };\n\n      _this._handleMinimize = function () {\n        setSelectedLog(-1);\n      };\n\n      _this._handleSetSelectedLog = function (index) {\n        setSelectedLog(index);\n      };\n\n      return _this;\n    }\n\n    _createClass(LogBoxStateSubscription, [{\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(err, errorInfo) {\n        reportLogBoxError(err, errorInfo.componentStack);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        if (this.state.hasError) {\n          return null;\n        }\n\n        return React.createElement(LogContext_1.LogContext.Provider, {\n          value: {\n            selectedLogIndex: this.state.selectedLogIndex,\n            isDisabled: this.state.isDisabled,\n            logs: Array.from(this.state.logs)\n          }\n        }, this.props.children, React.createElement(WrappedComponent, null));\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        var _this2 = this;\n\n        this._subscription = observe(function (data) {\n          _this2.setState(data);\n        });\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        if (this._subscription != null) {\n          this._subscription.unsubscribe();\n        }\n      }\n    }], [{\n      key: \"getDerivedStateFromError\",\n      value: function getDerivedStateFromError() {\n        return {\n          hasError: true\n        };\n      }\n    }]);\n\n    return LogBoxStateSubscription;\n  }(React.Component);\n\n  return LogBoxStateSubscription;\n}\n\nexports.withSubscription = withSubscription;","map":{"version":3,"sources":["../../../src/error-overlay/Data/LogBoxData.tsx"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Evan Bacon.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from \"react\";\n\nimport NativeLogBox from \"../modules/NativeLogBox\";\nimport parseErrorStack from \"../modules/parseErrorStack\";\nimport { LogBoxLog, StackType } from \"./LogBoxLog\";\nimport type { LogLevel } from \"./LogBoxLog\";\nimport { LogContext } from \"./LogContext\";\nimport { parseLogBoxException } from \"./parseLogBoxLog\";\nimport type {\n  Message,\n  Category,\n  ComponentStack,\n  ExtendedExceptionData,\n} from \"./parseLogBoxLog\";\n\nexport type LogBoxLogs = Set<LogBoxLog>;\n\nexport type LogData = {\n  level: LogLevel;\n  message: Message;\n  category: Category;\n  componentStack: ComponentStack;\n};\n\ntype ExtendedError = any;\n\nexport type Observer = (options: {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  selectedLogIndex: number;\n}) => void;\n\nexport type IgnorePattern = string | RegExp;\n\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\nexport type WarningInfo = {\n  finalFormat: string;\n  forceDialogImmediately: boolean;\n  suppressDialog_LEGACY: boolean;\n  suppressCompletely: boolean;\n  monitorEvent: string | null;\n  monitorListVersion: number;\n  monitorSampleRate: number;\n};\n\nexport type WarningFilter = (format: string) => WarningInfo;\n\ntype Props = object;\n\ntype State = {\n  logs: LogBoxLogs;\n  isDisabled: boolean;\n  hasError: boolean;\n  selectedLogIndex: number;\n};\n\nconst observers: Set<{ observer: Observer } & any> = new Set();\nconst ignorePatterns: Set<IgnorePattern> = new Set();\nlet logs: LogBoxLogs = new Set();\nlet updateTimeout:\n  | null\n  | ReturnType<typeof setImmediate>\n  | ReturnType<typeof setTimeout> = null;\nlet _isDisabled = false;\nlet _selectedIndex = -1;\n\nconst LOGBOX_ERROR_MESSAGE =\n  \"An error was thrown when attempting to render log messages via LogBox.\";\n\nfunction getNextState() {\n  return {\n    logs,\n    isDisabled: _isDisabled,\n    selectedLogIndex: _selectedIndex,\n  };\n}\n\nexport function reportLogBoxError(\n  error: ExtendedError,\n  componentStack?: string\n): void {\n  const ExceptionsManager = require(\"../modules/ExceptionsManager\");\n\n  if (componentStack != null) {\n    error.componentStack = componentStack;\n  }\n  ExceptionsManager.handleException(error);\n}\n\nexport function reportUnexpectedLogBoxError(\n  error: ExtendedError,\n  componentStack?: string\n): void {\n  error.message = `${LOGBOX_ERROR_MESSAGE}\\n\\n${error.message}`;\n  return reportLogBoxError(error, componentStack);\n}\n\nexport function isLogBoxErrorMessage(message: string): boolean {\n  return typeof message === \"string\" && message.includes(LOGBOX_ERROR_MESSAGE);\n}\n\nexport function isMessageIgnored(message: string): boolean {\n  for (const pattern of ignorePatterns) {\n    if (\n      (pattern instanceof RegExp && pattern.test(message)) ||\n      (typeof pattern === \"string\" && message.includes(pattern))\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction setImmediateShim(callback: () => void) {\n  if (!global.setImmediate) {\n    return setTimeout(callback, 0);\n  }\n  return global.setImmediate(callback);\n}\n\nfunction handleUpdate(): void {\n  if (updateTimeout == null) {\n    updateTimeout = setImmediateShim(() => {\n      updateTimeout = null;\n      const nextState = getNextState();\n      observers.forEach(({ observer }) => observer(nextState));\n    });\n  }\n}\n\nfunction appendNewLog(newLog: LogBoxLog): void {\n  // Don't want store these logs because they trigger a\n  // state update when we add them to the store.\n  if (isMessageIgnored(newLog.message.content)) {\n    return;\n  }\n\n  // If the next log has the same category as the previous one\n  // then roll it up into the last log in the list by incrementing\n  // the count (similar to how Chrome does it).\n  const lastLog = Array.from(logs).pop();\n  if (lastLog && lastLog.category === newLog.category) {\n    lastLog.incrementCount();\n    handleUpdate();\n    return;\n  }\n\n  if (newLog.level === \"fatal\") {\n    // If possible, to avoid jank, we don't want to open the error before\n    // it's symbolicated. To do that, we optimistically wait for\n    // symbolication for up to a second before adding the log.\n    const OPTIMISTIC_WAIT_TIME = 1000;\n\n    let addPendingLog: null | (() => void) = () => {\n      logs.add(newLog);\n      if (_selectedIndex < 0) {\n        setSelectedLog(logs.size - 1);\n      } else {\n        handleUpdate();\n      }\n      addPendingLog = null;\n    };\n\n    const optimisticTimeout = setTimeout(() => {\n      if (addPendingLog) {\n        addPendingLog();\n      }\n    }, OPTIMISTIC_WAIT_TIME);\n\n    // TODO: HANDLE THIS\n    newLog.symbolicate(\"component\");\n\n    newLog.symbolicate(\"stack\", (status) => {\n      if (addPendingLog && status !== \"PENDING\") {\n        addPendingLog();\n        clearTimeout(optimisticTimeout);\n      } else if (status !== \"PENDING\") {\n        // The log has already been added but we need to trigger a render.\n        handleUpdate();\n      }\n    });\n  } else if (newLog.level === \"syntax\") {\n    logs.add(newLog);\n    setSelectedLog(logs.size - 1);\n  } else {\n    logs.add(newLog);\n    handleUpdate();\n  }\n}\n\nexport function addLog(log: LogData): void {\n  const errorForStackTrace = new Error();\n\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      const stack = parseErrorStack(errorForStackTrace?.stack);\n\n      appendNewLog(\n        new LogBoxLog({\n          level: log.level,\n          message: log.message,\n          isComponentError: false,\n          stack,\n          category: log.category,\n          componentStack: log.componentStack,\n        })\n      );\n    } catch (error) {\n      reportUnexpectedLogBoxError(error);\n    }\n  });\n}\n\nexport function addException(error: ExtendedExceptionData): void {\n  // Parsing logs are expensive so we schedule this\n  // otherwise spammy logs would pause rendering.\n  setImmediate(() => {\n    try {\n      appendNewLog(new LogBoxLog(parseLogBoxException(error)));\n    } catch (loggingError) {\n      reportUnexpectedLogBoxError(loggingError);\n    }\n  });\n}\n\nexport function symbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function retrySymbolicateLogNow(type: StackType, log: LogBoxLog) {\n  log.retrySymbolicate(type, () => {\n    handleUpdate();\n  });\n}\n\nexport function symbolicateLogLazy(type: StackType, log: LogBoxLog) {\n  log.symbolicate(type);\n}\n\nexport function clear(): void {\n  if (logs.size > 0) {\n    logs = new Set();\n    setSelectedLog(-1);\n  }\n}\n\nexport function setSelectedLog(proposedNewIndex: number): void {\n  const oldIndex = _selectedIndex;\n  let newIndex = proposedNewIndex;\n\n  const logArray = Array.from(logs);\n  let index = logArray.length - 1;\n  while (index >= 0) {\n    // The latest syntax error is selected and displayed before all other logs.\n    if (logArray[index].level === \"syntax\") {\n      newIndex = index;\n      break;\n    }\n    index -= 1;\n  }\n  _selectedIndex = newIndex;\n  handleUpdate();\n  if (NativeLogBox) {\n    setTimeout(() => {\n      if (oldIndex < 0 && newIndex >= 0) {\n        NativeLogBox.show();\n      } else if (oldIndex >= 0 && newIndex < 0) {\n        NativeLogBox.hide();\n      }\n    }, 0);\n  }\n}\n\nexport function clearWarnings(): void {\n  const newLogs = Array.from(logs).filter((log) => log.level !== \"warn\");\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n    handleUpdate();\n  }\n}\n\nexport function clearErrors(): void {\n  const newLogs = Array.from(logs).filter(\n    (log) => log.level !== \"error\" && log.level !== \"fatal\"\n  );\n  if (newLogs.length !== logs.size) {\n    logs = new Set(newLogs);\n    setSelectedLog(-1);\n  }\n}\n\nexport function dismiss(log: LogBoxLog): void {\n  if (logs.has(log)) {\n    logs.delete(log);\n    handleUpdate();\n  }\n}\n\nexport function getIgnorePatterns(): IgnorePattern[] {\n  return Array.from(ignorePatterns);\n}\n\nexport function addIgnorePatterns(patterns: IgnorePattern[]): void {\n  const existingSize = ignorePatterns.size;\n  // The same pattern may be added multiple times, but adding a new pattern\n  // can be expensive so let's find only the ones that are new.\n  patterns.forEach((pattern: IgnorePattern) => {\n    if (pattern instanceof RegExp) {\n      for (const existingPattern of ignorePatterns) {\n        if (\n          existingPattern instanceof RegExp &&\n          existingPattern.toString() === pattern.toString()\n        ) {\n          return;\n        }\n      }\n      ignorePatterns.add(pattern);\n    }\n    ignorePatterns.add(pattern);\n  });\n  if (ignorePatterns.size === existingSize) {\n    return;\n  }\n  // We need to recheck all of the existing logs.\n  // This allows adding an ignore pattern anywhere in the codebase.\n  // Without this, if you ignore a pattern after the a log is created,\n  // then we would keep showing the log.\n  logs = new Set(\n    Array.from(logs).filter((log) => !isMessageIgnored(log.message.content))\n  );\n  handleUpdate();\n}\n\nexport function setDisabled(value: boolean): void {\n  if (value === _isDisabled) {\n    return;\n  }\n  _isDisabled = value;\n  handleUpdate();\n}\n\nexport function isDisabled(): boolean {\n  return _isDisabled;\n}\n\nexport function observe(observer: Observer): Subscription {\n  const subscription = { observer };\n  observers.add(subscription);\n\n  observer(getNextState());\n\n  return {\n    unsubscribe(): void {\n      observers.delete(subscription);\n    },\n  };\n}\n\nexport function withSubscription(\n  WrappedComponent: React.FC<object>\n): React.Component<object> {\n  class LogBoxStateSubscription extends React.Component<\n    React.PropsWithChildren<Props>,\n    State\n  > {\n    static getDerivedStateFromError() {\n      return { hasError: true };\n    }\n\n    componentDidCatch(err: Error, errorInfo: { componentStack: string } & any) {\n      /* $FlowFixMe[class-object-subtyping] added when improving typing for\n       * this parameters */\n      reportLogBoxError(err, errorInfo.componentStack);\n    }\n\n    _subscription?: Subscription;\n\n    state = {\n      logs: new Set<LogBoxLog>(),\n      isDisabled: false,\n      hasError: false,\n      selectedLogIndex: -1,\n    };\n\n    render() {\n      if (this.state.hasError) {\n        // This happens when the component failed to render, in which case we delegate to the native redbox.\n        // We can't show any fallback UI here, because the error may be with <View> or <Text>.\n        return null;\n      }\n\n      return (\n        <LogContext.Provider\n          value={{\n            selectedLogIndex: this.state.selectedLogIndex,\n            isDisabled: this.state.isDisabled,\n            logs: Array.from(this.state.logs),\n          }}\n        >\n          {this.props.children}\n          <WrappedComponent />\n        </LogContext.Provider>\n      );\n    }\n\n    componentDidMount(): void {\n      this._subscription = observe((data) => {\n        this.setState(data);\n      });\n    }\n\n    componentWillUnmount(): void {\n      if (this._subscription != null) {\n        this._subscription.unsubscribe();\n      }\n    }\n\n    _handleDismiss = (): void => {\n      // Here we handle the cases when the log is dismissed and it\n      // was either the last log, or when the current index\n      // is now outside the bounds of the log array.\n      const { selectedLogIndex, logs: stateLogs } = this.state;\n      const logsArray = Array.from(stateLogs);\n      if (selectedLogIndex != null) {\n        if (logsArray.length - 1 <= 0) {\n          setSelectedLog(-1);\n        } else if (selectedLogIndex >= logsArray.length - 1) {\n          setSelectedLog(selectedLogIndex - 1);\n        }\n\n        dismiss(logsArray[selectedLogIndex]);\n      }\n    };\n\n    _handleMinimize = (): void => {\n      setSelectedLog(-1);\n    };\n\n    _handleSetSelectedLog = (index: number): void => {\n      setSelectedLog(index);\n    };\n  }\n\n  // @ts-expect-error\n  return LogBoxStateSubscription;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}