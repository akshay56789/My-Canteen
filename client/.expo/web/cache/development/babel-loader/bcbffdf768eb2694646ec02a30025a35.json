{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LogBoxLog = void 0;\n\nvar LogBoxSymbolication = __importStar(require(\"./LogBoxSymbolication\"));\n\nfunction componentStackToStack(componentStack) {\n  return componentStack.map(function (stack) {\n    var _a, _b, _c, _d;\n\n    return {\n      file: stack.fileName,\n      methodName: stack.content,\n      lineNumber: (_b = (_a = stack.location) === null || _a === void 0 ? void 0 : _a.row) !== null && _b !== void 0 ? _b : 0,\n      column: (_d = (_c = stack.location) === null || _c === void 0 ? void 0 : _c.column) !== null && _d !== void 0 ? _d : 0,\n      arguments: []\n    };\n  });\n}\n\nvar LogBoxLog = function () {\n  function LogBoxLog(data) {\n    _classCallCheck(this, LogBoxLog);\n\n    var _a, _b;\n\n    this.symbolicated = {\n      stack: {\n        error: null,\n        stack: null,\n        status: \"NONE\"\n      },\n      component: {\n        error: null,\n        stack: null,\n        status: \"NONE\"\n      }\n    };\n    this.callbacks = new Map();\n    this.componentStackCache = null;\n    this.level = data.level;\n    this.type = (_a = data.type) !== null && _a !== void 0 ? _a : \"error\";\n    this.message = data.message;\n    this.stack = data.stack;\n    this.category = data.category;\n    this.componentStack = data.componentStack;\n    this.codeFrame = data.codeFrame;\n    this.isComponentError = data.isComponentError;\n    this.count = 1;\n    this.symbolicated = (_b = data.symbolicated) !== null && _b !== void 0 ? _b : this.symbolicated;\n  }\n\n  _createClass(LogBoxLog, [{\n    key: \"incrementCount\",\n    value: function incrementCount() {\n      this.count += 1;\n    }\n  }, {\n    key: \"getAvailableStack\",\n    value: function getAvailableStack(type) {\n      if (this.symbolicated[type].status === \"COMPLETE\") {\n        return this.symbolicated[type].stack;\n      }\n\n      return this.getStack(type);\n    }\n  }, {\n    key: \"flushCallbacks\",\n    value: function flushCallbacks(type) {\n      var callbacks = this.callbacks.get(type);\n      var status = this.symbolicated[type].status;\n\n      if (callbacks) {\n        for (var callback of callbacks) {\n          callback(status);\n        }\n\n        callbacks.clear();\n      }\n    }\n  }, {\n    key: \"pushCallback\",\n    value: function pushCallback(type, callback) {\n      var callbacks = this.callbacks.get(type);\n\n      if (!callbacks) {\n        callbacks = new Set();\n        this.callbacks.set(type, callbacks);\n      }\n\n      callbacks.add(callback);\n    }\n  }, {\n    key: \"retrySymbolicate\",\n    value: function retrySymbolicate(type, callback) {\n      this._symbolicate(type, true, callback);\n    }\n  }, {\n    key: \"symbolicate\",\n    value: function symbolicate(type, callback) {\n      this._symbolicate(type, false, callback);\n    }\n  }, {\n    key: \"_symbolicate\",\n    value: function _symbolicate(type, retry, callback) {\n      if (callback) {\n        this.pushCallback(type, callback);\n      }\n\n      var status = this.symbolicated[type].status;\n\n      if (status === \"COMPLETE\") {\n        return this.flushCallbacks(type);\n      }\n\n      if (retry) {\n        LogBoxSymbolication.deleteStack(this.getStack(type));\n        this.handleSymbolicate(type);\n      } else {\n        if (status === \"NONE\") {\n          this.handleSymbolicate(type);\n        }\n      }\n    }\n  }, {\n    key: \"getStack\",\n    value: function getStack(type) {\n      if (type === \"component\") {\n        if (this.componentStackCache == null) {\n          this.componentStackCache = componentStackToStack(this.componentStack);\n        }\n\n        return this.componentStackCache;\n      }\n\n      return this.stack;\n    }\n  }, {\n    key: \"handleSymbolicate\",\n    value: function handleSymbolicate(type) {\n      var _this = this;\n\n      var _a;\n\n      if (type === \"component\" && !((_a = this.componentStack) === null || _a === void 0 ? void 0 : _a.length)) {\n        return;\n      }\n\n      if (this.symbolicated[type].status !== \"PENDING\") {\n        this.updateStatus(type, null, null, null);\n        LogBoxSymbolication.symbolicate(this.getStack(type)).then(function (data) {\n          _this.updateStatus(type, null, data === null || data === void 0 ? void 0 : data.stack, data === null || data === void 0 ? void 0 : data.codeFrame);\n        }, function (error) {\n          _this.updateStatus(type, error, null, null);\n        });\n      }\n    }\n  }, {\n    key: \"updateStatus\",\n    value: function updateStatus(type, error, stack, codeFrame) {\n      var lastStatus = this.symbolicated[type].status;\n\n      if (error != null) {\n        this.symbolicated[type] = {\n          error: error,\n          stack: null,\n          status: \"FAILED\"\n        };\n      } else if (stack != null) {\n        if (codeFrame) {\n          this.codeFrame = codeFrame;\n        }\n\n        this.symbolicated[type] = {\n          error: null,\n          stack: stack,\n          status: \"COMPLETE\"\n        };\n      } else {\n        this.symbolicated[type] = {\n          error: null,\n          stack: null,\n          status: \"PENDING\"\n        };\n      }\n\n      var status = this.symbolicated[type].status;\n\n      if (lastStatus !== status) {\n        if ([\"COMPLETE\", \"FAILED\"].includes(status)) {\n          this.flushCallbacks(type);\n        }\n      }\n    }\n  }]);\n\n  return LogBoxLog;\n}();\n\nexports.LogBoxLog = LogBoxLog;","map":{"version":3,"sources":["../../../src/error-overlay/Data/LogBoxLog.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Evan Bacon.\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as LogBoxSymbolication from \"./LogBoxSymbolication\";\nimport type { Stack } from \"./LogBoxSymbolication\";\nimport type {\n  Category,\n  Message,\n  ComponentStack,\n  CodeFrame,\n} from \"./parseLogBoxLog\";\n\ntype SymbolicationStatus = \"NONE\" | \"PENDING\" | \"COMPLETE\" | \"FAILED\";\n\nexport type LogLevel = \"warn\" | \"error\" | \"fatal\" | \"syntax\" | \"static\";\n\nexport type LogBoxLogData = {\n  level: LogLevel;\n  type?: string;\n  message: Message;\n  stack: Stack;\n  category: string;\n  componentStack: ComponentStack;\n  codeFrame?: CodeFrame;\n  isComponentError: boolean;\n};\n\nexport type StackType = \"stack\" | \"component\";\n\nfunction componentStackToStack(componentStack: ComponentStack): Stack {\n  return componentStack.map((stack) => ({\n    file: stack.fileName,\n    methodName: stack.content,\n    lineNumber: stack.location?.row ?? 0,\n    column: stack.location?.column ?? 0,\n    arguments: [],\n  }));\n}\n\ntype SymbolicationCallback = (status: SymbolicationStatus) => void;\n\ntype SymbolicationResult =\n  | { error: null; stack: null; status: \"NONE\" }\n  | { error: null; stack: null; status: \"PENDING\" }\n  | { error: null; stack: Stack; status: \"COMPLETE\" }\n  | { error: Error; stack: null; status: \"FAILED\" };\n\nexport class LogBoxLog {\n  message: Message;\n  type: string;\n  category: Category;\n  componentStack: ComponentStack;\n  stack: Stack;\n  count: number;\n  level: LogLevel;\n  codeFrame?: CodeFrame;\n  isComponentError: boolean;\n  symbolicated: Record<StackType, SymbolicationResult> = {\n    stack: {\n      error: null,\n      stack: null,\n      status: \"NONE\",\n    },\n    component: {\n      error: null,\n      stack: null,\n      status: \"NONE\",\n    },\n  };\n\n  private callbacks: Map<StackType, Set<SymbolicationCallback>> = new Map();\n\n  constructor(\n    data: LogBoxLogData & {\n      symbolicated?: Record<StackType, SymbolicationResult>;\n    }\n  ) {\n    this.level = data.level;\n    this.type = data.type ?? \"error\";\n    this.message = data.message;\n    this.stack = data.stack;\n    this.category = data.category;\n    this.componentStack = data.componentStack;\n    this.codeFrame = data.codeFrame;\n    this.isComponentError = data.isComponentError;\n    this.count = 1;\n    this.symbolicated = data.symbolicated ?? this.symbolicated;\n  }\n\n  incrementCount(): void {\n    this.count += 1;\n  }\n\n  getAvailableStack(type: StackType): Stack | null {\n    if (this.symbolicated[type].status === \"COMPLETE\") {\n      return this.symbolicated[type].stack;\n    }\n    return this.getStack(type);\n  }\n\n  private flushCallbacks(type: StackType): void {\n    const callbacks = this.callbacks.get(type);\n    const status = this.symbolicated[type].status;\n    if (callbacks) {\n      for (const callback of callbacks) {\n        callback(status);\n      }\n      callbacks.clear();\n    }\n  }\n\n  private pushCallback(type: StackType, callback: SymbolicationCallback): void {\n    let callbacks = this.callbacks.get(type);\n    if (!callbacks) {\n      callbacks = new Set();\n      this.callbacks.set(type, callbacks);\n    }\n    callbacks.add(callback);\n  }\n\n  retrySymbolicate(\n    type: StackType,\n    callback?: (status: SymbolicationStatus) => void\n  ): void {\n    this._symbolicate(type, true, callback);\n  }\n\n  symbolicate(\n    type: StackType,\n    callback?: (status: SymbolicationStatus) => void\n  ): void {\n    this._symbolicate(type, false, callback);\n  }\n\n  private _symbolicate(\n    type: StackType,\n    retry: boolean,\n    callback?: (status: SymbolicationStatus) => void\n  ): void {\n    if (callback) {\n      this.pushCallback(type, callback);\n    }\n    const status = this.symbolicated[type].status;\n\n    if (status === \"COMPLETE\") {\n      return this.flushCallbacks(type);\n    }\n\n    if (retry) {\n      LogBoxSymbolication.deleteStack(this.getStack(type));\n      this.handleSymbolicate(type);\n    } else {\n      if (status === \"NONE\") {\n        this.handleSymbolicate(type);\n      }\n    }\n  }\n\n  private componentStackCache: Stack | null = null;\n\n  private getStack(type: StackType): Stack {\n    if (type === \"component\") {\n      if (this.componentStackCache == null) {\n        this.componentStackCache = componentStackToStack(this.componentStack);\n      }\n      return this.componentStackCache;\n    }\n    return this.stack;\n  }\n\n  private handleSymbolicate(type: StackType): void {\n    if (type === \"component\" && !this.componentStack?.length) {\n      return;\n    }\n\n    if (this.symbolicated[type].status !== \"PENDING\") {\n      this.updateStatus(type, null, null, null);\n      LogBoxSymbolication.symbolicate(this.getStack(type)).then(\n        (data) => {\n          this.updateStatus(type, null, data?.stack, data?.codeFrame);\n        },\n        (error) => {\n          this.updateStatus(type, error, null, null);\n        }\n      );\n    }\n  }\n\n  private updateStatus(\n    type: StackType,\n    error?: Error | null,\n    stack?: Stack | null,\n    codeFrame?: CodeFrame | null\n  ): void {\n    const lastStatus = this.symbolicated[type].status;\n    if (error != null) {\n      this.symbolicated[type] = {\n        error,\n        stack: null,\n        status: \"FAILED\",\n      };\n    } else if (stack != null) {\n      if (codeFrame) {\n        this.codeFrame = codeFrame;\n      }\n\n      this.symbolicated[type] = {\n        error: null,\n        stack,\n        status: \"COMPLETE\",\n      };\n    } else {\n      this.symbolicated[type] = {\n        error: null,\n        stack: null,\n        status: \"PENDING\",\n      };\n    }\n\n    const status = this.symbolicated[type].status;\n    if (lastStatus !== status) {\n      if ([\"COMPLETE\", \"FAILED\"].includes(status)) {\n        this.flushCallbacks(type);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}