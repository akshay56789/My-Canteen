{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"@babel/runtime/helpers/wrapNativeSuper\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchThenEvalAsync = void 0;\n\nfunction fetchThenEvalAsync(url) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      scriptType = _ref.scriptType,\n      nonce = _ref.nonce,\n      crossOrigin = _ref.crossOrigin;\n\n  if (typeof document === \"undefined\") {\n    throw new Error(\"Cannot use fetchThenEvalAsync in a non-browser environment.\");\n  }\n\n  return new Promise(function (resolve, reject) {\n    var script = document.createElement(\"script\");\n    if (scriptType) script.type = scriptType;\n    if (nonce) script.setAttribute(\"nonce\", nonce);\n    script.src = url;\n\n    if (crossOrigin && script.src.indexOf(window.location.origin + \"/\") !== 0) {\n      script.crossOrigin = crossOrigin;\n    }\n\n    script.onload = function () {\n      script.parentNode && script.parentNode.removeChild(script);\n      resolve();\n    };\n\n    var error = new AsyncRequireError();\n\n    script.onerror = function (ev) {\n      var _a;\n\n      var event;\n\n      if (typeof ev === \"string\") {\n        event = {\n          type: \"error\",\n          target: {\n            src: event\n          }\n        };\n      } else {\n        event = ev;\n      }\n\n      var errorType = event && (event.type === \"load\" ? \"missing\" : event.type);\n      var realSrc = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.src;\n      error.message = \"Loading module \" + url + \" failed.\\n(\" + errorType + \": \" + realSrc + \")\";\n      error.type = errorType;\n      error.request = realSrc;\n      script.parentNode && script.parentNode.removeChild(script);\n      reject(error);\n    };\n\n    document.head.appendChild(script);\n  });\n}\n\nexports.fetchThenEvalAsync = fetchThenEvalAsync;\n\nvar AsyncRequireError = function (_Error) {\n  _inherits(AsyncRequireError, _Error);\n\n  var _super = _createSuper(AsyncRequireError);\n\n  function AsyncRequireError() {\n    var _this;\n\n    _classCallCheck(this, AsyncRequireError);\n\n    _this = _super.apply(this, arguments);\n    _this.name = \"AsyncRequireError\";\n    return _this;\n  }\n\n  return _createClass(AsyncRequireError);\n}(_wrapNativeSuper(Error));","map":{"version":3,"sources":["../../src/async-require/fetchThenEval.web.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAOA,SAAgB,kBAAhB,CACE,GADF,EAMuE;EAAA,+EAAF,EAAE;EAAA,IAHnE,UAGmE,QAHnE,UAGmE;EAAA,IAFnE,KAEmE,QAFnE,KAEmE;EAAA,IADnE,WACmE,QADnE,WACmE;;EAErE,IAAI,OAAO,QAAP,KAAoB,WAAxB,EAAqC;IACnC,MAAM,IAAI,KAAJ,CACJ,6DADI,CAAN;EAGD;;EACD,OAAO,IAAI,OAAJ,CAAkB,UAAC,OAAD,EAAU,MAAV,EAAoB;IAC3C,IAAM,MAAM,GAAG,QAAQ,CAAC,aAAT,CAAuB,QAAvB,CAAf;IACA,IAAI,UAAJ,EAAgB,MAAM,CAAC,IAAP,GAAc,UAAd;IAChB,IAAI,KAAJ,EAAW,MAAM,CAAC,YAAP,CAAoB,OAApB,EAA6B,KAA7B;IAEX,MAAM,CAAC,GAAP,GAAa,GAAb;;IAEA,IAAI,WAAW,IAAI,MAAM,CAAC,GAAP,CAAW,OAAX,CAAmB,MAAM,CAAC,QAAP,CAAgB,MAAhB,GAAyB,GAA5C,MAAqD,CAAxE,EAA2E;MACzE,MAAM,CAAC,WAAP,GAAqB,WAArB;IACD;;IAED,MAAM,CAAC,MAAP,GAAgB,YAAK;MACnB,MAAM,CAAC,UAAP,IAAqB,MAAM,CAAC,UAAP,CAAkB,WAAlB,CAA8B,MAA9B,CAArB;MACA,OAAO;IACR,CAHD;;IAKA,IAAM,KAAK,GAAG,IAAI,iBAAJ,EAAd;;IAGA,MAAM,CAAC,OAAP,GAAiB,UAAC,EAAD,EAAO;;;MACtB,IAAI,KAAJ;;MACA,IAAI,OAAO,EAAP,KAAc,QAAlB,EAA4B;QAC1B,KAAK,GAAG;UACN,IAAI,EAAE,OADA;UAEN,MAAM,EAAE;YAEN,GAAG,EAAE;UAFC;QAFF,CAAR;MAOD,CARD,MAQO;QACL,KAAK,GAAG,EAAR;MACD;;MAED,IAAM,SAAS,GACb,KAAK,KAAK,KAAK,CAAC,IAAN,KAAe,MAAf,GAAwB,SAAxB,GAAoC,KAAK,CAAC,IAA/C,CADP;MAGA,IAAM,OAAO,GAAG,CAAA,EAAA,GAAA,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAK,KAAA,CAAL,GAAA,KAAK,CAAE,MAAP,MAAa,IAAb,IAAa,EAAA,KAAA,KAAA,CAAb,GAAa,KAAA,CAAb,GAAa,EAAA,CAAE,GAA/B;MACA,KAAK,CAAC,OAAN,GACE,oBACA,GADA,GAEA,aAFA,GAGA,SAHA,GAIA,IAJA,GAKA,OALA,GAMA,GAPF;MAQA,KAAK,CAAC,IAAN,GAAa,SAAb;MACA,KAAK,CAAC,OAAN,GAAgB,OAAhB;MAEA,MAAM,CAAC,UAAP,IAAqB,MAAM,CAAC,UAAP,CAAkB,WAAlB,CAA8B,MAA9B,CAArB;MACA,MAAM,CAAC,KAAD,CAAN;IACD,CA/BD;;IAgCA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,MAA1B;EACD,CApDM,CAAP;AAqDD;;AAlED,OAAA,CAAA,kBAAA,GAAA,kBAAA;;IAoEM,iB;;;;;EAAN,6BAAA;IAAA;;IAAA;;;IACW,MAAA,IAAA,GAAO,mBAAP;IADX;EAIC;;;mBAJ+B,K","sourcesContent":["/**\n * Copyright Â© 2022 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// Basically `__webpack_require__.l`.\nexport function fetchThenEvalAsync(\n  url: string,\n  {\n    scriptType,\n    nonce,\n    crossOrigin,\n  }: { scriptType?: string; nonce?: string; crossOrigin?: string } = {}\n): Promise<void> {\n  if (typeof document === \"undefined\") {\n    throw new Error(\n      \"Cannot use fetchThenEvalAsync in a non-browser environment.\"\n    );\n  }\n  return new Promise<void>((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    if (scriptType) script.type = scriptType;\n    if (nonce) script.setAttribute(\"nonce\", nonce);\n    // script.setAttribute('data-expo-metro', ...);\n    script.src = url;\n\n    if (crossOrigin && script.src.indexOf(window.location.origin + \"/\") !== 0) {\n      script.crossOrigin = crossOrigin;\n    }\n\n    script.onload = () => {\n      script.parentNode && script.parentNode.removeChild(script);\n      resolve();\n    };\n    // Create a new error object to preserve the original stack trace.\n    const error = new AsyncRequireError();\n\n    // Server error or network error.\n    script.onerror = (ev) => {\n      let event: Event;\n      if (typeof ev === \"string\") {\n        event = {\n          type: \"error\",\n          target: {\n            // @ts-expect-error\n            src: event,\n          },\n        };\n      } else {\n        event = ev;\n      }\n\n      const errorType =\n        event && (event.type === \"load\" ? \"missing\" : event.type);\n      // @ts-expect-error\n      const realSrc = event?.target?.src;\n      error.message =\n        \"Loading module \" +\n        url +\n        \" failed.\\n(\" +\n        errorType +\n        \": \" +\n        realSrc +\n        \")\";\n      error.type = errorType;\n      error.request = realSrc;\n\n      script.parentNode && script.parentNode.removeChild(script);\n      reject(error);\n    };\n    document.head.appendChild(script);\n  });\n}\n\nclass AsyncRequireError extends Error {\n  readonly name = \"AsyncRequireError\";\n  type?: string;\n  request?: string;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}